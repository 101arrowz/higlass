<!DOCTYPE html>
<html lang="">
<head>
<meta charset="utf-8">
<title>HiGlass: Multi-resolution Hi-C data display</title>
</head>
    
<script src="https://rawgit.com/pkerpedjiev/goomba/zoomable-genes/dist/scripts/goomba.js"></script>

<!-- build:css styles/style.css -->
<link rel="stylesheet" href="styles/page.css" />
<!-- endbuild -->

<!-- build:js scripts/higlass.js -->
<script src='scripts/higlass.js'></script>
<!-- endbuild -->

<body>
    <div class="main-div">

    <h1>HiGlass: Multi-resolution Hi-C data display</h1>
    <hr>

    <p>
    Each human cell has about 2 meters of DNA. This DNA is packaged within a
    nucleus that is only microns thick.  This is the equivalent of stuffing a
    string stretching from New York to Los Angeles into a container the size of
    a soccer ball. Needless to say, the arrangement is very compact and
    necessitates many contacts between distant regions of the DNA. To elucidate
    the nature and location of these interactions, Hi-C assays generate large
    amounts of information about which parts of human chromosomes are physically
    near to each other. In it's simplest form, this takes the form of a three-column list:
    </p>

    <pre>
    50000   50000   1.0
    60000   60000   1.0
    560000  565000  2.0
    565000  565000  23.0
    565000  570000  1.0
    </pre>

    <p>
    The first and second columns are locations on the genome and the third is a
    frequency of how often contacts between these regions are observed. The
    data in this example has a resolution of 5 Kb, indicating that we have
    aggregated contacts into bins of 5,000 DNA bases. Given the size of the
    human genome (~3e9 base pairs), a map of all 5 Kb contacts could be as
    large as 3.6e11 contacts (6e5 x 6e5). In practice, many regions are not in
    close proximity with each other leading to a much smaller sparse contact
    list.
    </p>

    <p> In the case of chromosome 1, which has approximately 2.5e8 nucleotides,
    the contact list has 42,447,494 entries. This table takes up nearly 1Gb of
    storage space uncompressed. Displaying such a large amount of data at once
    is beyond the capabilities of anything but the most sophisticated and
    powerful computers. To overcome this challenge, we break up the contact
    list into a set of 'tiles' which can be displayed at different zoom levels.
    Low resolution tiles aggregate the data in the high-resolution tiles and
    thus limit the total amount of data that needs to be displayed at any zoom
    level. The result, a viewer we dubbed HiGlass, opens a window into a 1Gb
    data set that can be explored through a browser on nearly any desktop
    computer.  
    </p>

<div id="mmv-area" style="position:relative; height:400px;" >
    <svg id="goombaPlot"></svg>
</div>
    <p>
    The axes here show the position along chromosome for which contact data is
    shown. The colors indicate the frequency and the dots on top show the positions
    of various annotated genes.
    </p>

    <p> The astute observer will note that this method of displaying data is
    remarkably similar to how popular online mapping tools work. It is, in
    fact, almost identical.  The only difference is the coordinate system used.
    Where in maps data (e.g. countries, cities, streets) is indexed by its latitude
    and longitude, here it is indexed by chromosome positions. The instantiation
    a higlass container is dead simple:

    <pre>
var width = 650, height=400;
var data_dir = 'http://pkerp.s3-website-us-east-1.amazonaws.com/tiles/chr1_5kb/';

var mmvPlot = higlass.MassiveMatrixPlot()
    .width(width)
    .height(height);


d3.json(data_dir + 'tile_info.json', 
function(error, tile_info) {
    mmvPlot.minX(tile_info.min_pos[0])
        .maxX(tile_info.max_pos[0])
        .minY(tile_info.min_pos[1])
        .maxY(tile_info.max_pos[1])
        .maxZoom(tile_info.max_zoom)
        .tileDirectory(data_dir)
        .zoomCallback(zoomCallback);

    d3.select('#mmv-area')
        .call(mmvPlot)
});
    </pre>

    We just point our container to the source of tiles and attach it to an HTML
    element.  The rest is handled by higlass. It's source code can be found
    on <a href="https://github.com/hms-dbmi/4DN_matrix-viewer">GitHub</a>.
    
    </p> </div>

<script type='text/javascript'>

    var width = 650, height=400;

var mmvPlot = higlass.MassiveMatrixPlot()
    .width(width)
    .height(height);

    var svg = d3.select('#goombaPlot')
    .attr('width', width)
    .attr('height', 80);

    // goomba gets drawn with a margin of 30 on the left
    // and a margin of 30 on the right
    // whereas higlass gets drawn with a margin of 30 on the left
    // and 120 on the right
    // thus goomba needs to be 90 smaller
        var goombaPlot = goomba.Goomba()
            .width(width - 90)
            .height(80)

            var gMain = svg.append('g')
            .classed('g-main', true)
            .datum('http://pkerp.s3-website-us-east-1.amazonaws.com/data/hg19/refgene-tiles-small')
            //.datum('jsons/tiles')
            .call(goombaPlot)

    function zoomCallback(scale, zoomLevel) {

        var xScale = goombaPlot.xScale();
        xScale.domain(scale.domain())

            goombaPlot.xScale(xScale)
            .currentZoom(zoomLevel)
            .draw();
    }

    d3.json('http://pkerp.s3-website-us-east-1.amazonaws.com/tiles/chr1_5kb/tile_info.json', function(error, tile_info) {
        //console.log('tile_info:', tile_info);
        mmvPlot.minX(tile_info.min_pos[0])
            .maxX(tile_info.max_pos[0])
            .minY(tile_info.min_pos[1])
            .maxY(tile_info.max_pos[1])
            .maxZoom(tile_info.max_zoom)
            .tileDirectory('http://pkerp.s3-website-us-east-1.amazonaws.com/tiles/chr1_5kb')
            .zoomCallback(zoomCallback);

        d3.select('#mmv-area')
            //.datum(data)
            .call(mmvPlot)
    });

</script>
</body>
</html>
