import slugid from 'slugid';
import pako from 'pako';

/**
 * Take a list of genes, which can be any list with elements containing
 * { start, end } fields and return another list of { start, end }
 * fields containing the collapsed genes.
 *
 * The segments should be sorted by their start coordinate.
 *
 * The scale parameter is the number of base pairs per pixels
 */
function collapse(segments, scale) {
  const collapsed = [];

  // the maximum distance we allow between segments before collapsing them
  const MAX_DIST_BETWEEN = 5;

  // no segments in, no segments out
  if (!segments.length) {
    return [];
  }

  // start with the first segment
  let currStart = segments[0].start;
  let currEnd = segments[0].end;

  // continue on to the next segments
  for (let i = 1; i < segments.length; i++) {
    if (segments[i].start < currEnd + MAX_DIST_BETWEEN * 1 / scale) {
      // this segment is within merging distance -- merge it
      currEnd = Math.max(currEnd, segments[i].end);
    } else {
      // this segment is outside of the merging distance, dump the current
      // collapsed segment and start a new one
      collapsed.push({
        type: 'filler',
        start: currStart,
        end: currEnd,
      });

      // start a new collapsed segment
      currStart = segments[i].start;
      currEnd = segments[i].end;
    }
  }

  // add the final segment
  collapsed.push({
    start: currStart,
    end: currEnd,
    type: 'filler',
  });

  return collapsed;
}

/**
 * Shuffles array in place.
 * @param {Array} a items An array containing the items.
 */
function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const x = a[i];
    a[i] = a[j];
    a[j] = x;
  }
  return a;
}

function gbToHgGene(gb) {
  const importance = gb.end - gb.start;
  const strand = gb.strand === 1 ? '+' : '-';
  const uid = slugid.nice();

  if (gb.type === 'filler') {
    // this is annotation that was generated by collapsing genes and is
    // only meant to show that there is something there.
    return {
      xStart: gb.start,
      xEnd: gb.end,
      strand: gb.strand,
      fields: [],
      type: 'filler',
      uid,
    };
  }

  return {
    xStart: gb.start,
    xEnd: gb.end,
    strand,
    chrOffset: 0,
    importance: gb.end - gb.start,
    uid,
    fields: [
      'chrom', gb.start, gb.end, gb.name, importance, strand, '', '', gb.type, gb.name, gb.start.toString(), gb.end.toString(), gb.start.toString(), gb.end.toString()
    ]
  };
}

function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
  const match = /^\s*/.exec(string);
  if (match !== null) {
    return match[0].length;
  }

  return 0;
}

function isFeatureLineRunon(line, featureLocationIndentation) {
  const indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
  if (featureLocationIndentation === indentationOfLine) {
    // the feature location indentation calculated right after the feature tag
    // cannot be the same as the indentation of the line
    //
    // FEATURES             Location/Qualifiers
    //     rep_origin      complement(1074..3302)
    // 01234  <-- this is the indentation we're talking about
    return false; // the line is NOT a run on
  }

  const trimmed = line.trim();
  if (trimmed.charAt(0).match(/\//)) {
    // the first char in the trimmed line cannot be a /
    return false; // the line is NOT a run on
  }
  // the line is a run on
  return true;
  // run-on line example:
  // FEATURES             Location/Qualifiers
  //     rep_origin      complement(1074..3302)
  //                 /label=pSC101**
  //                 /note="REP_ORIGIN REP_ORIGIN pSC101* aka pMPP6, gives plasm
  //                 id number 3 -4 copies per cell, BglII site in pSC101* ori h <--run-on line!
  //                 as been dele ted by quick change agatcT changed to agatcA g <--run-on line!
  //                 iving pSC101* * pSC101* aka pMPP6, gives plasmid number 3-4 <--run-on line!
  //                 copies p er cell, BglII site in pSC101* ori has been delet  <--run-on line!
  //                 ed by quic k change agatcT changed to agatcA giving pSC101* <--run-on line!
  //                 * [pBbS0a-RFP]"                                             <--run-on line!
  //                 /gene="SC101** Ori"
  //                 /note="pSC101* aka pMPP6, gives plasmid number 3-4 copies p
  //                 er cell, BglII site in pSC101* ori has been deleted by qui
  //                 c k change agatcT changed to agatcA giving pSC101**"
  //                 /vntifkey="33"
}

function genbankToJson(sequence) {
  const MONTHS = [
    'JAN',
    'FEB',
    'MAR',
    'APR',
    'MAY',
    'JUN',
    'JUL',
    'AUG',
    'SEP',
    'OCT',
    'NOV',
    'DEC'
  ];

  // Genbank specification: https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html
  const genbankAnnotationKey = {
    // Contains in order: locus name, sequence length, molecule type (e.g. DNA),
    // genbank division (see 1-18 below), modification date
    // locus definition has changed with time, use accession
    // number for a unique identifier
    LOCUS_TAG: 'LOCUS',
    DEFINITION_TAG: 'DEFINITION',
    // Accession tag
    // Example: Z78533
    ACCESSION_TAG: 'ACCESSION',
    // The version tag contains 2 informations
    // The accession number with a revision
    // The GI (GenInfo Identifier), a ncbi sequential number
    // Example: Z78533.1  GI:2765658
    // Unicity garanteed with respect to sequence. If 1 nucleotide changes,
    // the version is different.
    VERSION_TAG: 'VERSION',
    KEYWORDS_TAG: 'KEYWORDS',
    // SEGMENT_TAG:"SEGMENT"
    // Source is free text
    SOURCE_TAG: 'SOURCE',
    ORGANISM_TAG: 'ORGANISM',
    REFERENCE_TAG: 'REFERENCE',
    AUTHORS_TAG: 'AUTHORS',
    CONSORTIUM_TAG: 'CONSRTM',
    TITLE_TAG: 'TITLE',
    // Can be multiple journal tags
    JOURNAL_TAG: 'JOURNAL',
    PUBMED_TAG: 'PUBMED',
    REMARK_TAG: 'REMARK',
    FEATURES_TAG: 'FEATURES',
    BASE_COUNT_TAG: 'BASE COUNT',
    // CONTIG_TAG: "CONTIG"
    ORIGIN_TAG: 'ORIGIN',
    END_SEQUENCE_TAG: '//'
  };

  // Genbank divisions
  //   1. PRI - primate sequences
  //   2. ROD - rodent sequences
  //   3. MAM - other mammalian sequences
  //   4. VRT - other vertebrate sequences
  //   5. INV - invertebrate sequences
  //   6. PLN - plant, fungal, and algal sequences
  //   7. BCT - bacterial sequences
  //   8. VRL - viral sequences
  //   9. PHG - bacteriophage sequences
  // 10. SYN - synthetic sequences
  // 11. UNA - unannotated sequences
  // 12. EST - EST sequences (expressed sequence tags)
  // 13. PAT - patent sequences
  // 14. STS - STS sequences (sequence tagged sites)
  // 15. GSS - GSS sequences (genome survey sequences)
  // 16. HTG - HTG sequences (high-throughput genomic sequences)
  // 17. HTC - unfinished high-throughput cDNA sequencing
  // 18. ENV - environmental sampling sequences

  if (typeof sequence !== 'string') {
    throw new TypeError('sequence must be a string');
  }

  const resultsArray = [];
  let result;
  let currentFeatureNote;

  const lines = sequence.split(/\r?\n/);
  let fieldName;
  let subFieldType;
  let featureLocationIndentation;

  if (lines === null) {
    throw new Error('sequence file is empty');
  }
  let hasFoundLocus = false;


  function postProcessGenbankFeature(feat) {
    if (feat.notes.label) {
      feat.name = feat.notes.label[0];
    } else if (feat.notes.gene) {
      feat.name = feat.notes.gene[0];
    } else if (feat.notes.ApEinfo_label) {
      feat.name = feat.notes.ApEinfo_label[0];
    } else if (feat.notes.name) {
      feat.name = feat.notes.name[0];
    } else if (feat.notes.organism) {
      feat.name = feat.notes.organism[0];
    } else if (feat.notes.locus_tag) {
      feat.name = feat.notes.locus_tag[0];
    } else if (feat.notes.note) {
      feat.name = feat.notes.note[0];
    } else {
      feat.name = 'Untitled Feature';
    }
    feat.name = typeof feat.name === 'string' ? feat.name : String(feat.name);
    return feat;
  }

  function postProcessCurSeq() {
    if (result && result.features) {
      for (let i = 0; i < result.features.length; i++) {
        result.features[i] = postProcessGenbankFeature(result.features[i]);
      }
    }
  }

  function endSeq() {
    // do some post processing clean-up
    postProcessCurSeq();
    // push the result into the resultsArray
    resultsArray.push(result);
  }

  function getCurrentFeature() {
    return result.features[result.features.length - 1];
  }

  function parseOrigin(line, key) {
    if (key !== genbankAnnotationKey.ORIGIN_TAG) {
      const newLine = line.replace(/[\s]*[0-9]*/g, '');
      result.sequence += newLine;
    }
  }

  function removeFieldName(localFieldName, line) {
    line = line.replace(/^\s*/, '');
    if (line.indexOf(localFieldName) === 0) {
      line = line.replace(localFieldName, '');
    }
    return line.trim();
  }

  function parseLocus(line) {
    result = {
      features: [],
      name: 'Untitled sequence',
      sequence: ''
    };
    line = removeFieldName(genbankAnnotationKey.LOCUS_TAG, line);
    const m = line.match(
      /^([^\s]+)\s+(\d+)\s+bp\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)$/
    );
    const locusName = m[1];
    const size = +m[2];
    const moleculeType = m[3];
    const circular = m[4] === 'circular';
    const genbankDivision = m[5];

    const seq = result;
    seq.circular = circular;
    seq.moleculeType = moleculeType;
    seq.genbankDivision = genbankDivision;
    const dateMatch = m[6].match(/^(\d{2})-(.{3})-(\d{4})$/);
    const date = new Date();
    date.setFullYear(+dateMatch[3]);
    date.setUTCMonth(MONTHS.indexOf(dateMatch[2].toUpperCase()));
    date.setDate(+dateMatch[1]);
    date.setUTCHours(12);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    seq.date = date.toISOString();
    seq.name = locusName;
    seq.size = size;
  }

  let lastLineWasFeaturesTag;
  let lastLineWasLocation;

  function newFeature() {
    result.features.push({
      locations: [],
      notes: {}
    });
  }

  function isNote(line) {
    let qual = false;
    /* if (line.charAt(21) === "/") {// T.H. Hard coded method
           qual = true;
        } */
    if (
      line
        .trim()
        .charAt(0)
        .match(/\//)
    ) {
      // searches based on looking for / in beginning of line
      qual = true;
    } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
      // searches based on "   /key=BLAH" regex
      qual = true;
    }
    return qual;
  }

  function parseFeatureLocation(locStr) {
    locStr = locStr.trim();
    const locArr = [];
    locStr.replace(/(\d+)/g, (string, match) => {
      locArr.push(match);
    });

    const feat = getCurrentFeature();
    feat.start = +locArr[0];
    feat.end = +locArr[1];
  }

  function parseFeatureNote(line) {
    let newLine = line.trim();
    newLine = newLine.replace(/^\/|"$/g, '');
    const lineArr = newLine.split(/="|=/);

    let val = lineArr[1];

    if (val) {
      val = val.replace(/\\/g, ' ');

      if (line.match(/="/g)) {
        val = val.replace(/".*/g, '');
      } else if (val.match(/^\d+$/g)) {
        val = +val;
      }
    }

    const key = lineArr[0];
    const currentNotes = getCurrentFeature().notes;
    if (currentNotes[key]) {
      // array already exists, so push value into it
      currentNotes[key].push(val);
    } else {
      // array doesn't exist yet, so create it and populate it with the value
      currentNotes[key] = [val];
    }
    currentFeatureNote = currentNotes[key];
  }

  function getLineFieldName(line) {
    let arr;
    line = line.replace(/^[\s]*/, '');

    if (line.indexOf('=') < 0) {
      arr = line.split(/[\s]+/);
    } else {
      arr = line.split(/=/);
    }

    return arr[0];
  }

  function parseMultiLineField(localFieldName, line, resultKey, r) {
    r = r || result;
    const fieldValue = removeFieldName(localFieldName, line);
    r[resultKey] = r[resultKey] ? `${r[resultKey]} ` : '';
    r[resultKey] += fieldValue;
  }

  function parseReference(line, subType) {
    const refs = result.references;
    const lastRef = refs[refs.length - 1];
    if (!subType) {
      parseMultiLineField(
        genbankAnnotationKey.REFERENCE_TAG,
        line,
        'description',
        lastRef
      );
    } else {
      parseMultiLineField(subType, line, subType.toLowerCase(), lastRef);
    }
  }

  function getLineVal(line) {
    if (line.indexOf('=') < 0) {
      line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, '');
      line = line.trim();
      return line;
    }

    const arr = line.split(/=/);
    return arr[1];
  }

  function isKeyword(line) {
    let isKey = false;
    if (line.substr(0, 10).match(/^[\S]+/)) {
      isKey = true;
    }
    return isKey;
  }

  function isSubKeyword(line) {
    let isSubKey = false;
    if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
      isSubKey = true;
    }
    return isSubKey;
  }

  function parseFeatures(line, key, val) {
    let strand;
    // FOR THE MAIN FEATURES LOCATION/QUALIFIER LINE
    if (key === genbankAnnotationKey.FEATURES_TAG) {
      lastLineWasFeaturesTag = true;
      return;
    }

    if (lastLineWasFeaturesTag) {
      // we need to get the indentation of feature locations
      featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(
        line
      );
      // set lastLineWasFeaturesTag to false
      lastLineWasFeaturesTag = false;
    }

    // FOR LOCATION && QUALIFIER LINES
    if (isFeatureLineRunon(line, featureLocationIndentation)) {
      // the line is a continuation of the above line
      if (lastLineWasLocation) {
        // the last line was a location, so the run-on line is expected to
        // be a feature location as well
        parseFeatureLocation(line.trim());
        lastLineWasLocation = true;
      } else {
        // the last line was a note
        if (currentFeatureNote) {
          // append to the currentFeatureNote
          currentFeatureNote[
            currentFeatureNote.length - 1
          ] += line.trim().replace(/"/g, '');
        }
        lastLineWasLocation = false;
      }
    } else if (isNote(line)) {
    // New Element/Qualifier lines. Not runon lines.

      // is a new Feature Element (e.g. source, CDS) in the form of  "[\s] KEY  SEQLOCATION"
      // is a FeatureQualifier in the /KEY="BLAH" format; could be multiple per Element
      // Check that feature did not get skipped for missing location
      if (getCurrentFeature()) {
        parseFeatureNote(line);
        lastLineWasLocation = false;
      }
    } else {
      // the line is a location, so we make a new feature from it
      if (val.match(/complement/g)) {
        strand = -1;
      } else {
        strand = 1;
      }

      newFeature();
      const feat = getCurrentFeature();
      feat.type = key;
      feat.strand = strand;

      parseFeatureLocation(val);
      lastLineWasLocation = true;
    }
  }


  for (const line of lines) {
    if (line === null) break;
    const lineFieldName = getLineFieldName(line);
    const val = getLineVal(line);
    const isSubKey = isSubKeyword(line);
    const isKey = isKeyword(line);

    if (lineFieldName === genbankAnnotationKey.END_SEQUENCE_TAG || isKey) {
      fieldName = lineFieldName;
      subFieldType = null;
    } else if (isSubKey) {
      subFieldType = lineFieldName;
    }
    // IGNORE LINES: DO NOT EVEN PROCESS
    if (line.trim() === '' || lineFieldName === ';') {
      continue;
    }

    if (!hasFoundLocus && fieldName !== genbankAnnotationKey.LOCUS_TAG) {
      // 'Genbank files must start with a LOCUS tag so this must not be a genbank'
      break;
    }

    switch (fieldName) {
      case genbankAnnotationKey.LOCUS_TAG:
        hasFoundLocus = true;
        parseLocus(line);
        break;
      case genbankAnnotationKey.FEATURES_TAG:
        parseFeatures(line, lineFieldName, val);
        break;
      case genbankAnnotationKey.ORIGIN_TAG:
        parseOrigin(line, lineFieldName);
        break;
      case genbankAnnotationKey.DEFINITION_TAG:
      case genbankAnnotationKey.ACCESSION_TAG:
      case genbankAnnotationKey.VERSION_TAG:
      case genbankAnnotationKey.KEYWORDS_TAG:
        parseMultiLineField(fieldName, line, fieldName.toLowerCase());
        break;
      case genbankAnnotationKey.SOURCE_TAG:
        if (subFieldType === genbankAnnotationKey.ORGANISM_TAG) {
          parseMultiLineField(subFieldType, line, 'organism');
        } else {
          parseMultiLineField(lineFieldName, line, 'source');
        }
        break;
      case genbankAnnotationKey.REFERENCE_TAG:
        if (lineFieldName === genbankAnnotationKey.REFERENCE_TAG) {
          const ref = result.references || [];
          result.references = ref;
          ref.push({});
        }
        parseReference(line, subFieldType);
        break;
      case genbankAnnotationKey.END_SEQUENCE_TAG:
        endSeq();
        break;
      default:
        // Unhandled tag
        break;
    }
  }

  // catch the case where we've successfully started a sequence and parsed it,
  // but endSeq isn't called correctly
  if (resultsArray[resultsArray.length - 1] !== result) {
    // current result isn't in resultsArray yet
    // so we call endSeq here
    endSeq();
  }
  return resultsArray;
}

class GBKDataFetcher {
  constructor(dataConfig) {
    this.dataConfig = dataConfig;
    this.trackUid = slugid.nice();

    this.dataPromise = fetch(dataConfig.url, {
      headers: {
        'Content-Encoding': 'gzip'
      },
      mode: 'cors'
    })
      .then(response => response.arrayBuffer())
      .then((buffer) => {
        const gffText = pako.inflate(buffer, { to: 'string' });
        this.gbJson = genbankToJson(gffText);
        this.cdss = shuffle(this.gbJson[0]
          .features.filter(f => f.type === 'gene')
          .sort((a, b) => a.start - b.start));
      });
  }

  tilesetInfo(callback) {
    return this.dataPromise.then(() => {
      const TILE_SIZE = 1024;
      let retVal = {};
      // retVal[this.trackUid] = {
      retVal = {
        tile_size: TILE_SIZE,
        max_zoom: Math.ceil(
          Math.log(this.gbJson[0].size / TILE_SIZE) / Math.log(2)
        ),
        max_width: this.gbJson[0].size,
        min_pos: [0],
        max_pos: [this.gbJson[0].size],
      };

      if (callback) {
        callback(retVal);
      }

      return retVal;
    });
  }

  fetchTilesDebounced(receivedTiles, tileIds) {
    const tiles = {};

    const validTileIds = [];
    const tilePromises = [];

    for (const tileId of tileIds) {
      const parts = tileId.split('.');
      const z = parseInt(parts[0], 10);
      const x = parseInt(parts[1], 10);

      if (Number.isNaN(x) || Number.isNaN(z)) {
        console.warn('Invalid tile zoom or position:', z, x);
        continue;
      }

      validTileIds.push(tileId);
      tilePromises.push(this.tile(z, x));
    }

    Promise.all(tilePromises).then((values) => {
      for (let i = 0; i < values.length; i++) {
        const validTileId = validTileIds[i];
        tiles[validTileId] = values[i];
        tiles[validTileId].tilePositionId = validTileId;
      }

      receivedTiles(tiles);
    });
    // tiles = tileResponseToData(tiles, null, tileIds);
    return tiles;
  }

  tile(z, x) {
    return this.tilesetInfo().then((tsInfo) => {
      const tileWidth = +tsInfo.max_width / 2 ** (+z);

      // get the bounds of the tile
      const minX = tsInfo.min_pos[0] + x * tileWidth;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;

      const filtered = this.cdss.filter(v => v.end > minX && v.start < maxX);
      const scaleFactor = 1024 / (2 ** (tsInfo.max_zoom - z));

      const collapsedPlus = collapse(filtered.filter(v => v.strand === 1), scaleFactor);
      const collapsedMinus = collapse(filtered.filter(v => v.strand !== 1), scaleFactor);

      collapsedPlus.forEach((v) => { v.strand = '+'; });
      collapsedMinus.forEach((v) => { v.strand = '-'; });

      let values = [];
      const TILE_CAPACITY = 20;
      // fill the tile with entries that are within it
      for (let i = 0; i < this.cdss.length; i++) {
        if (values.length >= TILE_CAPACITY) break;

        if (this.cdss[i].end >= minX && this.cdss[i].start <= maxX) {
          values.push(this.cdss[i]);
        }
      }

      values = [...values, ...collapsedPlus, ...collapsedMinus];
      // values = values.concat(collapsedPlus).concat(collapsedMinus);
      // we're not going to take into account importance
      return values.map(v => gbToHgGene(v));
    });
  }
}

export default GBKDataFetcher;
